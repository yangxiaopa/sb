clear all
load node.out
plot(node(4:end,1)-3,node(4:end,2))
hold on
plot(node(4:end,1)-3,(node(4:end,8)-node(4:end,2)),'r')
plot(node(4:end,1)-3,(node(4:end,14)-node(4:end,8)),'g')
legend('first interstory drift [m]','second interstory drift [m]','third interstory drift [m]')

x=0:pi/100:2*pi;
y=sin(x);
plot(x,y,'r--')
xlabel('x') 
ylabel('sin(x)') 
title('Plot of the Sine Function')
hold on
y2=cos(x);
plot(x,y2,'b:')
legend('sin','cos')
hold off

[a,b]=meshgrid(-2:0.2:2);
c=a.*exp(-a.^2 - b.^2);
surf(a,b,c)

t=0:pi/100:2*pi;
[x,y,z]=cylinder(4*cos(t));
subplot(2,2,1); mesh(x); title('x');
subplot(2,2,2); mesh(y); title('y');
subplot(2,2,3); mesh(z); title('z');
subplot(2,2,4); mesh(x,y,z); title('x,y,z');

+ - * / \ ^ ' ()   矩阵运算符
+ - .* ./ .\ .^ .' 阵列运算符（元素与元素件运算）

常见的数据精确度类型
char---带符号的字符8bits
short---短整数16bits
long---长整数16bits
float---单精度浮点数32bits
double---双精度浮点数32bits

格式转换符
%c---读取字符型变量   %s---读取字符串变量   %d---读取整数型变量

inf---infinity  NaN---not a number 

-----------------------------------matlab对数据文件的操作---------------------------------
1.文件每一行的数据项数是相同的(数据为矩形形状)，每个数据项由一个或多个空格分隔开，内容恰好构成一个矩阵
clear all；删除工作区的所有变量
A=load('nod_rea_result\totalnode.out')
A=load('node1.out') >>> 将文件导入工作空间并赋给变量A

2.若文件的数据内容由逗号分隔开，把该文件的内容全部读入阵列A >>>  A=dlmread('node1.out',',')

3.处理一个包含文本头的的数据文件，可使用textread函数，并指定头行参数，textread可处理有固定格式的文件，也可处理无格式文件，还可对文件中每行数据按列读
num1    num2    num3    num4
0.3242  0.4324  0.3455  0.6754
0.4566  0.9368  0.9892  0.9274
0.4658  0.2832  0.9373  0.8233
[num1,num2,num3,num4]=textread('testFile.txt','%f%f%f%f','headerlines',1)

textread读取字母数字混合的数据
Joe    gradeA  4.9  pass
susan  gradeD  2.0  fail
[name,gra,grades,answer] = textread('testFile.txt','%s%s%f%s')
可选择的读取数据，如读取第一列和最后一列，可使用命令：
[name,answer] = textread('testFile.txt','%s%*s%*f%s')

textread处理文件分隔符为非空格的文件，textread函数将该分隔符作为其参数，比如文件中分隔符为分号，可使用如下命令：
[name,gra,grades,answer] = textread('testFile.txt','%s%s%f%s','delimiter',';')

4.使用导入函数读取二进制文件
函数名称 读取文件的扩展名 数据格式
load .mat	aviread .avi	cdfread .cdf	hdf .hdf	waveread .wav	xlsread .xls
5.二进制数据的存写
函数名称 读取文件的扩展名 数据格式
save .mat	avifile .avi	cdfwriter .cdf	 hdf .hdf	wavewrite.wav	xlswrite .xls



ans（answer）是matlab中默认的结果变量，每次结果运算后都将存储在指定变量中，只输入表达式却不指定变量，matlab自动将结果存储在ans变量中。
如果用分号“；”结束语句, matlab 将执行计算, 但阻止在命令窗口中显示输出。
转置矩阵A,将行与列对换命令为A'
矩阵A的逆，inv（A)
.* .^ 为矩阵内部元素的乘法和幂次方
水平串联矩阵a用逗号，可表示为b=[a,a]
垂直串联矩阵a用分号，可表示为b=[a;a]

矩阵元素的操作
   16 2  3  13
A= 5  11 10 8
   9  7  6  12
   4  14 15 1
A（4，2）ans=14 定位矩阵A 的4行12列元素
A（1:3,2) ans=2 输出矩阵A1到3行的第二列
	      11	
              7
A（3，：）ans=9 7 6 12 输出矩阵A的三行所有列

B=0：10：100 ans=0 10 20 30 40 50 60 70 80 90 100  star : step : end  若省略中间部，此时默认为1

zeros all zeros
ones  all ones 
rand  uniformly distributed random elements
rands normally distributed random elements

z=zeros(2,4) z=0 0 0 0
               0 0 0 0 
f=5*ones(3,3)
f=5 5 5
  5 5 5 
  5 5 5
n=(0:9)'  pows=[n n.^2 2.^n]  
n= 0     pows=   0   0   1
   1             1   1   2
   2             2   4   4
   3             3   9   8
   4             4   16  16
   5             5   25  32
   6             6   36  64
   7             7   49  128
   8             8   64  81
   9             9   81  512

x=A;
x(:,2)=[] >>> 使矩阵A第二列为空

X(1:2,2:3) = 0 >>> 使矩阵相应位置上的这4个元素为0





	      
help funname   在命令窗口打开帮助文档
doc funname    在帮助浏览器打开帮助文档
lookfor funname 搜索某关键字相关函数

1.MATLAB中计算程序运行时间的代码
tic
%代码块
toc
dispdisp(['运行时间：',num2str(toc)])

2.创建保存输出文件的目录
mkdir(Make Directory创建目录)创建目录时应保证新建的目录没有重名
mkdir('F:\zzzzzzzzzzzzz\matlab_and_opensees_test\output22') %创建文件夹
if { [file exists output] == 0 } {
	  file mkdir output;
}  
# 如果文件夹output不存在，创建一个output文件夹。

3.  which co.tcl 
 显示当前co.tcl工作目录

exist
用于判断目录或者文件是否存在

对文件的操作
f=fullfile('D:','MATLAB','example.txt'); %得到打开文件的信息     ***
fid=fopen(f);        %打开文件，fid=-1表示打开文件失败；fid=1表示输出；fid=2表示错误信息文件 fid=其他正数表示文件打开成功，并返回文件编号
d =fscanf(fid,'%c');  fid=fopen(f,'r')以读的方式打开文件，打开方式有：r, w, a, r+, w+, a+, A, W
fclose(fid); %关闭文件，关闭多个文件有fclose('all')

load
可用于读取数值文件，并且无需打开文件，但要求文件中所有行的列数相同  ***
f=fullfile('D:','MATLAB','example.txt');
A=load（f);%返回以f为路径的文件的内容

fread
读取文件中的内容，需和fopen,fclose配合使用，返回的是ASCII码，可以指定返回字节数和返回的格式。
f=fullfile('D:','Matlab','example.txt'); 
fid = fopen(f, 'r'); 
a=fread(fid); %读取文件全部内容，fread函数返回的是每个字节的ASCII码赋给变量a

fscanf
用于读取文件中指定格式的内容，需和需和fopen,fclose配合使用，可指定读取的字节数，返回内容存放在一个一维数组中
f=fullfile('D:','Matlab','example.txt');
fid = fopen(f, 'r');
a=fscanf(fid,'%d'); %读取文件中的所有数字，返回到数组a中         ***
[a,count]=fscanf(fid,'%d',5); %读取文件中fid指向位置开始后面的5个数字，返回到数组a中，count返回a的大小，count<=5(返回的数字个数可能小于要求
fclose(fid);                   读取的个数)

fgetl
用于读取文件中的一行内容，不包括换行符，需和fopen,fclose配合使用，
f=fullfile('D:','Matlab','example.txt');
fid = fopen(f, 'r');
tline=fgetl(fid); %从文件中读取fid指向的一行内容

fprintf
用于将指定格式数据写入到文件中，需和fopen,fclose配合使用
y = [x; exp(x)];
f=fullfile('D:','Matlab','example.txt');
fid = fopen(f,'w');
fprintf(fid,'%6.2f.8f\n',y);将矩阵y写入文件中

feof
用于判断是否为文件末尾，需和fopen,fclose配合使用
f=fullfile('D:','Matlab','example.txt');
fid = fopen(f, 'r');

%3d  >>>按照长度为三的整型输出 比如10 为”_10" 
%6.2f >>>输出总长度为6，小数后保留2位 比如3.14159 为 “_ _ _3.14"
%s 或 %c >>>输出字符串
Supported conversion specifications:
         %n - read a number - float or integer (returns double array)
              %5n reads up to 5 digits or until next delimiter
         %d - read a signed integer value (returns double array)
              %5d reads up to 5 digits or until next delimiter
         %u - read an integer value (returns double array)
              %5u reads up to 5 digits or until next delimiter
         %f - read a floating point value (returns double array)
              %5f reads up to 5 digits or until next delimiter
         %s - read a whitespace separated string (returns cellstr)
              %5s reads up to 5 characters or until whitespace
         %q - read a double-quoted string, ignoring the quotes (returns cellstr)
              %5q reads up to 5 non-quote characters or until whitespace
         %c - read character or whitespace (returns char array)
              %5c reads up to 5 characters including whitespace


------------------------------------------MATLAB遗传算法--------http://codem.group.shef.ac.uk/index.php/ga-toolbox
matlab的三种遗传算法工具箱：
1：gaot工具箱，非matlab软件自带的工具箱，任然可以自己配置使用。飞思科技的《matlab6.x辅助优化计算与设计》第五章对遗传算法使用有介绍
2：gatbx工具箱，由英国设菲尔德sheffield大学开发的gatbas工具箱，非matlab软件自带工具箱。雷杰英《matlab遗传算法工具箱及应用》有详细使用说明
3：gads工具箱，matlab自带的工具箱，可查看雷杰英《matlab遗传算法工具箱及应用》进一步了解

遗传算法工具箱的安装步骤：1.解压gatbx.rar文件至matlab目录下的toolbox的文件夹 2.运行matlab，在设置路径里添加gatbx工具箱
（***注意，当用matlab来编写遗传算法代码时，根据自己所安装的工具箱来编写代码。

遗传算法（genetic algorithm 缩写为GA)：可有效解决最优化问题的方法，遗传算法是模拟达尔文的遗传选择和自然淘汰的生物进化过程的计算模型，借鉴生物遗传
现象使具有一定数量的候选解的种群向更好的解进化，使适应度函数代入估计参数后达到最值来得到最优解，遗传算法先随机产生一组初始解，作为初始种群，以数值解
为例，这些解通过二进制代码存储在计算机中，类似于染色体，可进行生物上的交叉、变异、遗传等。每一代通过适应度函数来淘汰劣性个体，后代由前一代保留下的染色体
通过“交叉”或“变异”形成，在新一代的形成过程中总是根据适应度值来保留个体，从而保持种群大小为常数。适应度值高的染色体被选中概率较高，遗传若干代后算法收敛
于最好的染色体或达到预先设定的遗传代数，则停止计算，返回最优解
  
将问题域中的可能解看作群体的个体或染色体，并将每一个个体编码成符号串形式，模拟达尔文的遗传选择和自然淘汰的生物进化过程，对群体反复进行遗传学的遗传、交叉
和变异（变异具有阻止局部最优收敛的作用）操作，根据目标适应度函数对每个个体进行评价并依据优胜劣汰的规则不断得到更优的的群体，同时以并行搜索方式来搜索优化群体得到全局最优解。
-------*******-----------**********--------------**********---------********------
wright声称使用实值基因的遗传算法在数值函数优化上与二进制编码相比有许多优点，，在函数计算前，不需要从染色体到表现值的转换，可提高遗传算法的效率；计算机
内部的高效浮点表示可直接使用。减少内存的需求，相对于离散的二进制或其他值，没有精度损失，对使用不同的遗传算子非常自由。michalewicz在
《进化策略（evolution strategies》中描述使用实值编码的细节
----------------------------------------------------------


遗传算法中的通用函数：
bs2rv（binary string to real vector):二进制串到实值的转换  
Chrom=crtbp(4,8)  %创建任意染色体，如为二进制串
Chrom =

     1     1     1     1     0     1     1     1
     1     0     1     0     1     0     1     0
     0     0     0     1     1     1     1     1
     1     1     1     0     1     1     0     0
FieldD=[8;-1;10;1;0;1;1]   %译码矩阵将二进制串矩阵Chrom转换为实值向量
FieldD =

     8
    -1
    10
     1
     0
     1
     1
Phen=bs2rv(Chrom,FieldD)  %转换二进制到实值
Phen =

    6.1176
    7.8000
   -0.0941
    6.8941
-------------------
BaseV=crtbase([4 6],[8 5])  %创建基向量

BaseV =

     8     8     8     8     5     5     5     5     5     5
crtbase产生向量的元素对应染色体结构的基因座，使用不同的基因字符表示建立种群时该函数可与函数crtbp联合使用
BaseV=crtbase([4 5],[8 4])

BaseV =

     8     8     8     8     4     4     4     4     4
[Chrom,Lind,BaseV]=crtbp(6,BaseV)

Chrom =

     1     7     2     0     0     2     2     3     1
     0     7     0     1     1     2     0     0     1
     1     3     6     7     3     2     2     3     2
     1     3     3     7     0     1     0     3     2
     3     2     1     4     0     2     1     1     3
     0     7     3     0     0     1     2     1     3


Lind =

     9


BaseV =

     8     8     8     8     4     4     4     4     4
-------------------------------------------------------
crtrp  %创建实值原始种群
--------------------------
migrate  %在子种群间迁移个体
[Chrom, ObjV] = migrate(Chrom, SUBPOP, MigOpt, ObjV)  %migrate完成在当前种群Chrom的子种群间迁移个体，并返回迁移后的种群Chrom.Chrom的一行对应一个个体，子种群数量由SUBPOP指定
[Chrom, ObjV] = migrate(Chrom, SUBPOP, [0.3 1 2], ObjV)
在一子种群中选择30%的个体并用从单向环状结构的临近子种群中选择最适应（较小的ObjV）的个体替换
--------------------------
mut %离散变异算子
NewChrom = mut(OldChrom,Pm,BaseV)  %使用第三个变量指明染色体个体元素的变异的基本字符，染色体结构的长度Lind=length(BaseV)
BaseV=[8 8 8 4 4 4 4 4]

BaseV =

     8     8     8     4     4     4     4     4
[Chrom, Lind, BaseV]=crtbp(6,BaseV)

Chrom =

     5     7     3     0     3     2     1     3
     3     4     1     1     3     1     1     0
     6     4     6     1     1     2     1     3
     4     4     1     3     0     2     2     2
     2     1     1     1     1     0     0     1
     7     2     1     0     1     0     1     2


Lind =

     8


BaseV =

     8     8     8     4     4     4     4     4
NewChrom = mut(Chrom, 0.0778, BaseV)

NewChrom =

     5     7     1     0     3     2     1     3
     3     4     1     1     3     1     1     0
     6     4     6     1     1     0     1     3
     4     4     1     3     0     2     2     1
     2     1     1     1     1     0     0     1
     7     2     1     0     1     0     1     2
     
--------------------------
mutate   %个体的变异（高级函数）
NewChrom = mutate(MUT_F, OldChrom, FieldDR, MutOpt, SUBPOP) 
对于二进制种群,选取MUT_F='mut'  对于十进制种群，选取MUT_F='mutbga'
Chrom=crtbp(6,BaseV)

Chrom =

     2     2     1     3     0     1     1     2
     3     5     1     2     3     0     1     1
     4     5     7     0     2     2     2     2
     7     4     1     1     1     0     1     0
     3     5     0     1     0     1     3     3
     7     5     4     3     1     2     3     3
     
FieldDR=[0 0 0 0 0 0 0 0; 8 8 8 4 4 4 4 4]

FieldDR =

     0     0     0     0     0     0     0     0
     8     8     8     4     4     4     4     4     
NewChrom = mutate('mutbga', Chrom, FieldDR)

NewChrom =

    2.0000    2.0000    1.0000    3.0000         0    1.0000    1.0000    2.0000
    3.0000    5.0000    1.0000    2.0000    3.0000         0    1.0000    1.0000
    4.0000    5.0000    7.0000         0    1.9961    2.0000    2.0000    2.0000
    7.0000    4.0000    1.0000    1.0000    1.0000         0    1.0000         0
    3.0000    5.0000         0    1.0000         0    1.0000    3.0000    3.0000
    7.0000    5.0000    4.0000    3.0000    1.0000    2.0000    3.0000    3.0000
---------------------------------
mutbga	%实值种群的变异 （遗传算法育种器的变异算子）
NewChrom = mutbga(OldChrom, FieldDR, MutOpt)  mutbga对实值种群OldChrom，使用给定的概率，变异每一个变量，返回变异后的种群NewChrom
--------------------------------
ranking	%基于秩的适应度计算
FitnV = ranking(ObjV, RFun, SUBPOP)	%ranking按照个体的目标值ObjV由小到大的顺序对他们进行排序，并返回一包含对应个体适应度值FitnV的列向量，如果ranking被调用于多子种群，
则ranking独立的每个子种群执行，
ObjV = [1 2 3 4 5 10 9 8 7 6]'

ObjV =

     1
     2
     3
     4
     5
    10
     9
     8
     7
     6
FitnV = ranking(ObjV)

FitnV =

    2.0000
    1.7778
    1.5556
    1.3333
    1.1111
         0
    0.2222
    0.4444
    0.6667
    0.8889
----------------------------    
recdis	%离散重组
NewChrom = recdis(OldChrom, XOVR)	%recdis完成当前种群OldChrom中一对个体的离散重组，在交配后返回新的种群NewChrom.recdis为低级重组函数，通常被recombin调用
OldChrom = [40.23 -17.17 28.95 15.38; 82.06 13.26 13.35 -9.09; 52.43 25.64 15.20 -2.54; -47.50 49.10 9.09 10.65; -90.50 -13.46 -25.63 -0.89]

OldChrom =

   40.2300  -17.1700   28.9500   15.3800
   82.0600   13.2600   13.3500   -9.0900
   52.4300   25.6400   15.2000   -2.5400
  -47.5000   49.1000    9.0900   10.6500
  -90.5000  -13.4600  -25.6300   -0.8900
NewChrom = recdis(OldChrom)

NewChrom =

   40.2300   13.2600   13.3500   -9.0900
   40.2300   13.2600   13.3500   15.3800
  -47.5000   49.1000   15.2000   -2.5400
  -47.5000   49.1000    9.0900   10.6500
  -90.5000  -13.4600  -25.6300   -0.8900  
------------------------------------
recint	%中间重组，recdis只能应用于实值变量种群的函数，recdis为低级重组函数，通常被recombin调用
NewChrom = recint(OldChrom, XOVR)
OldChrom = [40.23 -17.17 28.95 15.38; 82.06 13.26 13.35 -9.09; 52.43 25.64 15.20 -2.54; -47.50 49.10 9.09 10.65; -90.50 -13.46 -25.63 -0.89]

NewChrom = recint(OldChrom)

NewChrom =

   80.8923  -18.9812   18.0528   11.2752
   89.8513  -17.5833   10.4523   -7.8768
  -58.3612   51.9167   15.8335    4.9826
  -67.2195   53.9302   12.2790   -3.0303
  -90.5000  -13.4600  -25.6300   -0.8900
-------------------------------------------
reclin	%线性重组，reclin完成当前种群OldChrom成对个体的线性重组，返回交配后的新种群NewChrom.OldChrom每一行对应一个个体，reclin只能应用于实值变量种群的函数
reclin为低级重组函数，通常被recombin调用
OldChrom = [40.23 -17.17 28.95 15.38; 82.06 13.26 13.35 -9.09; 52.43 25.64 15.20 -2.54]

OldChrom =

   40.2300  -17.1700   28.9500   15.3800
   82.0600   13.2600   13.3500   -9.0900
   52.4300   25.6400   15.2000   -2.5400
NewChrom = reclin(OldChrom)

NewChrom =

   56.2359   -5.5262   22.9808    6.0168
   87.2303   17.0212   11.4218  -12.1146
   52.4300   25.6400   15.2000   -2.5400   
------------------------------------------
recmut	%具有变异特征的线性重组
NewChrom = recmut(OldChrom, FieldDR, MutOpt)
recmut完成当前种群OldChrom成对个体的具有突变特征的线性重组，返回交配后的新种群NewChrom.recmut只能应用于实值变量种群的函数,recmut为低级重组函数，通常被recombin调用
OldChrom = [40.23 -17.17 28.95 15.38; 82.06 13.26 13.35 -9.09; 52.43 25.64 15.20 -2.54; -47.50 49.10 9.09 10.65; -90.50 -13.46 -25.63 -0.89]

OldChrom =

   40.2300  -17.1700   28.9500   15.3800
   82.0600   13.2600   13.3500   -9.0900
   52.4300   25.6400   15.2000   -2.5400
  -47.5000   49.1000    9.0900   10.6500
  -90.5000  -13.4600  -25.6300   -0.8900
FieldDR = [-100 -50 -30 -20; 100 50 30 20]

FieldDR =

  -100   -50   -30   -20
   100    50    30    20
NewChrom = recmut(OldChrom,FieldDR)

NewChrom =

   40.2300  -17.1700   28.9500   15.3800
   82.0600   13.2600   13.3500   -9.0900
 -100.0000  -23.2503    7.5601  -13.5351
  100.0000   50.0000   16.7299   20.0000
  -90.5000  -13.4600  -25.6300   -0.8900
------------------------------------------
recombin	%重组个体（高级函数）
NewChrom = recombin(REC_F, OldChrom, RecOpt, SUBPOP)

BaseV = [-100 -50 -30 -20; 100 50 30 20]

BaseV =

  -100   -50   -30   -20
   100    50    30    20
Chrom = crtrp(5, BaseV)

Chrom =

    9.4431  -24.5718  -18.2043   13.2331
  -72.2751   31.4285  -14.9350    3.4106
  -70.1412  -25.6475    6.9627    1.9889
  -48.4983   42.9264   -1.6027   16.6877
   68.1435  -15.0016   -8.9004   -8.5664   

NewChrom = recombin('recdis',Chrom)			%参数选取离散重组

NewChrom =

  -72.2751  -24.5718  -18.2043    3.4106
  -72.2751   31.4285  -18.2043   13.2331
  -48.4983   42.9264    6.9627   16.6877
  -70.1412  -25.6475    6.9627   16.6877
   68.1435  -15.0016   -8.9004   -8.5664

NewChrom = recombin('xovsp',Chrom)			%参数选取单点交叉

NewChrom =

    9.4431   31.4285  -14.9350    3.4106
  -72.2751  -24.5718  -18.2043   13.2331
  -70.1412  -25.6475   -1.6027   16.6877
  -48.4983   42.9264    6.9627    1.9889
   68.1435  -15.0016   -8.9004   -8.5664

%recombin检测输入参数的一致性并调用低级重组函数，如果recombin调用时具有多个子种群，则对每个子种群分别调用低级重组函数。
------------------------------------------------
reins	%一致随机和基于适应度的重插入
[Chrom, ObjVCh] = reins(Chrom, SelCh, SUBPOP, InsOpt, ObjVCh, ObjVSel)
%reins完成插入子代到当前种群，用子代代替父代并返回结果种群，子代包含在矩阵SelCh中，父代在矩阵Chrom中，Chrom和selCh中每一行对应一个个体
FieldDR = [-10 -5 -3 -1; 10 5 3 1]	%定义边界变量

FieldDR =

   -10    -5    -3    -1
    10     5     3     1
    
Chrom = crtrp(6,FieldDR)		%产生6个个体的父代种群

Chrom =

   -4.7406   -2.7102   -2.5309    0.6346
    3.0816    4.1334   -0.3439    0.7374
    3.7843   -3.4762   -2.3601   -0.8311
    4.9630    3.2582    2.7714   -0.2004
   -0.9892    0.3834   -2.9722   -0.4803
   -8.3236    4.9613    1.6495    0.6001

FieldDR1 = [-100 -50 -30 -20; 100 50 30 20]		%定义边界变量

FieldDR1 =

  -100   -50   -30   -20
   100    50    30    20
SelCh = crtrp(2,FieldDR1)			%产生2个个体的子代种群

SelCh =

  -13.7172  -31.8153  -21.2677   14.7717
   82.1295  -23.6197  -21.8359    3.1882

Chrom = reins(Chrom, SelCh)			%插入所有子代到种群中

Chrom =

   -4.7406   -2.7102   -2.5309    0.6346
  -13.7172  -31.8153  -21.2677   14.7717
    3.7843   -3.4762   -2.3601   -0.8311
    4.9630    3.2582    2.7714   -0.2004
   82.1295  -23.6197  -21.8359    3.1882
   -8.3236    4.9613    1.6495    0.6001

ObjVCh = [21; 22; 23; 24; 25; 26]		%为父种群考虑目标值ObjVCh向量

ObjVCh =

    21
    22
    23
    24
    25
    26
Chrom = reins(Chrom, SelCh, 1, 1, ObjVCh)

Chrom =

   -4.7406   -2.7102   -2.5309    0.6346
  -13.7172  -31.8153  -21.2677   14.7717
    3.7843   -3.4762   -2.3601   -0.8311
    4.9630    3.2582    2.7714   -0.2004
   82.1295  -23.6197  -21.8359    3.1882
  -13.7172  -31.8153  -21.2677   14.7717
------------------------------------------
rep	%矩阵的复制
MatOut = rep(MatIn,REPN)	%rep为低级复制函数，通常不直接使用，可被GA工具箱中许多函数调用
Matin = [1 2 3 4; 5 6 7 8]

Matin =

     1     2     3     4
     5     6     7     8
Matin = rep(Matin, [1,2])

Matin =

     1     2     3     4     1     2     3     4
     5     6     7     8     5     6     7     8
--------------------------------------------------
rws	%轮盘赌选择
NewChrIx = rws(FitnV, Nsel)	%rws在当前种群中按照他们的适应度FitnV选择Nsel个个体繁殖.rws是一低级选择函数，通常被select调用
FitnV = [1.50; 1.35; 1.21; 1.07; 0.92; 0.78; 0.64;0.5]

FitnV =

    1.5000
    1.3500
    1.2100
    1.0700
    0.9200
    0.7800
    0.6400
    0.5000

NewChrIx = rws(FitnV,6)

NewChrIx =

     3
     1
     2
     1
     1
     2
-----------------------------
scaling		%线性适应度计算
FitnV = scaling(ObjV, Smul)	%scaling转换一种群的目标值ObjV为由Smul的值决定上界的适应度值，FitnV = ObjV.*a + b，目标值ObjV为负时
ObjV = [1; 2; 3; 4; 5; 6]

ObjV =

     1
     2
     3
     4
     5
     6
fitnV = scaling(ObjV)

fitnV =

         0
    1.4000
    2.8000
    4.2000
    5.6000
    7.0000
---------------------
select  %从种群中选择个体（高级函数）
SelCh = select(SEL_F, Chrom, FitnV, GGAP, SUBPOP)	%利用函数select从种群Chrom中选择优良个体，并将选择的个体返回到新种群SelCh中，
Chrom和SelCh中每一行对应一个个体，SEL_F包含一低级的选择函数名，如rws或sus.FitnV为种群Chrom中个体的适应度值，表明每个个体被选择的预期概率
GGAP为可选参数，指出代沟，部分总群被复制。默认为GGAP为1，也可大于1允许子代多余父代数量.SUBPOP为可选参数，决定子种群的数量
Chrom = [1 11 21;2 12 22;3 13 23;4 14 24;5 15 25;6 16 26;7 17 27;8 18 28]

Chrom =

     1    11    21
     2    12    22
     3    13    23
     4    14    24
     5    15    25
     6    16    26
     7    17    27
     8    18    28
FitnV = [1.50;1.35;1.21;1.07;0.92;0.78;0.64;0.5]

FitnV =

    1.5000
    1.3500
    1.2100
    1.0700
    0.9200
    0.7800
    0.6400
    0.5000
SelCh = select('sus',Chrom,FitnV,2,2)

SelCh =

     1    11    21
     3    13    23
     4    14    24
     2    12    22
     2    12    22
     4    14    24
     1    11    21
     2    12    22
     6    16    26
     7    17    27
     5    15    25
     5    15    25
     6    16    26
     5    15    25
     7    17    27
     8    18    28
---------------------
sus %随机遍历抽样
NewChrIx = sus(FitnV, Nsel)	%sus按照个体在当前种群中的适应度FitnV为繁殖概率性选择Nsel个个体.sus是一低级函数，通常被select调用
FitnV = [1.50;1.35;1.21;1.07;0.92;0.78;0.64;0.5]

FitnV =

    1.5000
    1.3500
    1.2100
    1.0700
    0.9200
    0.7800
    0.6400
    0.5000
NewChrIx = sus(FitnV,6)

NewChrIx =

     6
     7
     1
     2
     3
     4
------------------
xovdp	%两点交叉
NewChrom = xovdp(OldChrom, XOVR)	%xovdp完成当前种群OldChrom中一对个体按交叉概率XOVR进行交叉，返回交配后的新种群NewChrom.XOVR是可选参数
表明交叉概率，xovdp为低级交叉函数，被函数recombin调用
-------------
xovdprs		%减少代理的两点交叉
NewChrom = xovdprs(OldChrom, XOVR) 	%xovdprs在当前种群OldChrom中一对个体间按交叉概率XOVR进行减少代理两点交叉，并返回交配后的新种群NewChrom
xovdprs为低级交叉函数，被函数recombin调用
OldChrom=crtbp(5,6)

OldChrom =

     1     1     1     1     0     0
     0     0     0     0     0     0
     1     0     1     1     1     0
     0     0     1     0     0     1
     1     1     0     0     1     0
NewChrom = xovdprs(OldChrom, 0.7)

NewChrom =

     1     1     0     1     0     0
     0     0     1     0     0     0
     1     0     1     0     1     0
     0     0     1     1     0     1
     1     1     0     0     1     0
-------------------------------------
xovmp		%多点交叉，xovmp为低级交叉函数，被调用
NewChrom =  xovmp(OldChrom, Px, Npt, Rs)
---------------------------------------
xovsh	%洗牌交叉，为低级交叉函数，被函数recombin调用
NewChrom = xovsh(OldChrom, XOVR)
OldChrom=crtbp(5,6)

OldChrom =

     0     0     1     1     1     0
     0     0     1     1     1     1
     0     0     1     0     0     1
     1     0     1     1     1     1
     0     1     1     1     0     1
NewChrom = xovsh(OldChrom, 0.7)

NewChrom =

     0     0     1     1     1     0
     0     0     1     1     1     1
     1     0     1     0     1     1
     0     0     1     1     0     1
     0     1     1     1     0     1
--------------------------------------
xovshrs		%减少代理的洗牌交叉，为低级交叉函数，被函数recombin调用
NewChrom = xovshrs(OldChrom, XOVR)
OldChrom=crtbp(5,6)

OldChrom =

     1     0     0     1     1     1
     0     0     1     1     0     0
     0     0     1     1     0     0
     1     1     1     1     0     0
     0     1     0     1     0     0     
NewChrom = xovshrs(OldChrom, 0.7)

NewChrom =

     0     0     0     1     1     1
     1     0     1     1     0     0
     1     1     1     1     0     0
     0     0     1     1     0     0
     0     1     0     1     0     0
------------------------------------
xovsp		%单点交叉，为低级交叉函数，被函数recombin调用
NewChrom = xovsp(OldChrom, XOVR)
OldChrom=crtbp(5,6)

OldChrom =

     0     0     0     1     1     0
     0     0     0     1     1     0
     0     0     0     1     1     1
     1     0     0     0     0     0
     0     1     0     0     1     0
NewChrom = xovsp(OldChrom, 0.7)

NewChrom =

     0     0     0     1     1     0
     0     0     0     1     1     0
     0     0     0     1     0     0
     1     0     0     0     1     1
     0     1     0     0     1     0     
-------------------------------------
xovsprs		%减少代理的单点交叉，，为低级函数，通常被函数recombin调用
NewChrom = xovsprs(OldChrom, XOVR)
OldChrom=crtbp(5,6)

OldChrom =

     1     1     0     0     1     1
     1     1     1     0     0     0
     1     1     1     1     1     0
     1     0     1     0     0     0
     0     0     0     0     0     1
NewChrom = xovsprs(OldChrom, 0.7)

NewChrom =

     1     1     0     0     0     0
     1     1     1     0     1     1
     1     1     1     0     0     0
     1     0     1     1     1     0
     0     0     0     0     0     1
--------------------------------------
1.种群的表示与初始化
2.目标函数与适应度函数（目标函数必须由用户创建，以obj为前缀名，线性尺度变换函数scaling不适用于目标函数产生负的适应度值的情况）
3.选择
4.交叉（产生新染色体的基本操作称为染色体的交叉，也称基因重组.多点交叉的破坏性可促进解空间的搜索而不至于在搜索中因高适应度个体过早收敛，使搜索健壮）
5.变异（采用一任意小的概率0.001~0.1，改变染色体元素.其作用：搜索任意给定串的可能性永不为零，为保证通过选择和交叉操作恢复可能丢失的好的遗传物质提供安全网络）
	实值编码在高变异率中比二进制编码好，提高了对搜索空间的搜索能力，而不会对收敛特诊产生不利影响。
遗传算法是随机搜索算法，设定明确的收敛性判别标准困难，在搜寻最优个体之前的许多代种群适应度可能保持不变，程序的终止搜寻成为问题，通常方法采用预先设定代
数来终止遗传算法或根据问题定义测试种群中最优个体的性能.
----------------
由于使用了代沟，子代的数量比当前种群数量要小,
	
	



































定义变量
函数表达式的定义
函数的约束条件：
（比如等式约束，含等式约束的目标优化问题是常见的比较难用遗传算法求解的一类问题。若用等式约束，遗传算法在进化过程中会出现大量的非可行解。甚至连续十几代
全部个体都为非可行解，一个可行解没有，所以就不会收敛）经典的处理方法有：1.直接采取罚函数的处理约束等式约束。2.将等式约束化成一个新的目标，用多目标优化
算法处理等式约束的问题，该法可极大的扩宽所研究问题的可行解区域，从而使得遗传算法方便的进行最优解的搜索；存在的弊端就是该法对可行解的扩宽程度较大，使用
多目标优化算法求解，得到的结果是帕累托最优解集。问题易出在搜索时接的分布性不好儿而导致搜索到的帕累托前沿种并不包含使得上述新增目标到达绝对最优的解，从
而导致所有帕累托最优解均不满足该等式约束，因此方法2也会导致算法的不稳定。3.采用数学方法降维消除等式约束，该法利用数学推导与等式约束，将其中一个或
多个变量用其余变量线性表出或非线型表出，从而使模型降维，同时也成功消除等式约束，该法在效果上是最好的，其局限性是：对于复杂的等式约束，无法将其中一个
或多个变量用其余变量线性表出或非线型表出时，该法无法使用。应优先使用方法3再考虑1和2
函数的变量范围



































